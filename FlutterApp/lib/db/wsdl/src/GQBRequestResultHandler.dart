
//------------------------------------------------------------------------
//
// Generated by www.easywsdl.com
// Version: 8.0.1.0
//
// Created by Quasar Development 
//
// This class has been generated for test purposes only and cannot be used in any commercial project.
// To use it in commercial project, you need to generate this class again with Premium account.
// Check https://EasyWsdl.com/Payment/PremiumAccountDetails to see all benefits of Premium account.
//
// Licence: CA3F4CEB7486F6668BD6F181D6CA68F608603F641897C20DF217C55FE3F3416F64E665190F35F5CE91CF8F38D5FB78FB96170CE35D755393898FFBDA2F093BF2
//------------------------------------------------------------------------
part of com.example.testSoap.wcf;

enum GQBSoapVersion{
    v1_0,
    v1_1,
    v1_2
}

typedef GQBISerializableObject CreatorFunction();

abstract class GQBISerializableObject
{
    Future<void> loadWithXml(XmlElement __node, GQBRequestResultHandler __handler);
    Future<void> serialize(XmlElement __parent, GQBRequestResultHandler __handler);
}

abstract class GQBIReferenceObject
{
}

class GQBSoapException implements Exception{
    XmlElement? details;
    String? message;
    Object? fault;
    
    GQBSoapException(this.message,this.details);

    GQBSoapException.WithFault(Object fault){
        this.fault=fault;
    }
}

class GQBRequestResultHandler
{
    static GQBIDateTimeParser DateTimeConverter = GQBDateTimeParser();
    GQBSoapVersion Version=GQBSoapVersion.v1_1;
    bool createClassesForAny=false;

    XmlElement? Body;
    XmlElement? Header;

    XmlElement? OutputBody;
    XmlElement? OutputHeader;
    
    XmlDocument? _doc;
    static final Map< Type,String> _reverseClassNames = {
        GQBTableColumn:"http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^TableColumn",
        GQBRowCell:"http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^RowCell",
        GQBArrayOfTableColumn:"http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^ArrayOfTableColumn",
        GQBArrayOfRowCell:"http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^ArrayOfRowCell",
        GQBArrayOfstring:"http://schemas.microsoft.com/2003/10/Serialization/Arrays^^ArrayOfstring",
    };

    static final Map< String, CreatorFunction> _classNames = {
        "http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^TableColumn":()=>GQBTableColumn(),
        "http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^RowCell":()=>GQBRowCell(),
        "http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^ArrayOfTableColumn":()=>GQBArrayOfTableColumn(),
        "http://schemas.datacontract.org/2004/07/DB.WebService.Contract^^ArrayOfRowCell":()=>GQBArrayOfRowCell(),
        "http://schemas.microsoft.com/2003/10/Serialization/Arrays^^ArrayOfstring":()=>GQBArrayOfstring(),
    };

    static final Map< String,String> _elementNames = {
    };
        
    final Map< String,String> _namespaces = 
    {
        GQBHelper.MS_SERIALIZATION_NS:'ms',
        GQBHelper.XSI: 'xsi'
    };
    final Map< String,Object> _referencesTable = {};
    final Map< Object,String> _reverseReferencesTable= {};
    String soapNS="";

    GQBRequestResultHandler(GQBSoapVersion version)
    {
        Version=version;
    }

    XmlDocument createEnvelopeXml() {
        soapNS=Version==GQBSoapVersion.v1_2 ? "http://www.w3.org/2003/05/soap-envelope" : "http://schemas.xmlsoap.org/soap/envelope/";
        final xml = XmlBuilder();

        xml.element("Envelope", namespace: soapNS, nest: ()
        {
            xml.namespace(soapNS, 'soap');
            xml.namespace(GQBHelper.MS_SERIALIZATION_NS, 'ms');
            xml.namespace(GQBHelper.XSI, 'xsi');
            xml.element("Header", namespace: soapNS);
            xml.element("Body", namespace: soapNS);
        });

        _doc= xml.buildDocument();
        
        Body=_doc!.rootElement.findElements("Body",namespace: soapNS).first;
        Header=_doc!.rootElement.findElements("Header",namespace: soapNS).first;
        return _doc!;
    }
    
    void finishEnvelopeXml(XmlDocument doc)
    {
        
    }

    String _ensureNamespace(String namespace)
    {
        String prefix="";
        if(namespace.isNotEmpty)
        {
            if(_namespaces.containsKey(namespace))
            {
                prefix=_namespaces[namespace]!;
            }
            else
            {
                prefix="ns"+_namespaces.length.toString();
                _namespaces[namespace]=prefix;
                _doc!.rootElement.attributes.add(XmlAttribute(XmlName(prefix, "xmlns"), namespace));
            }
        }
        return prefix;
    }

    XmlElement writeElement(String name,String namespace)
    {
        String prefix=_ensureNamespace(namespace);
        var newElement=XmlElement(XmlName(name,prefix));
        return newElement;
    }

    XmlAttribute? addAttribute(XmlElement element,String name,String namespace,String value)
    {
        _ensureNamespace(namespace);
        element.setAttribute(name, value,namespace: namespace);
        return GQBHelper.getAttribute(element,name, namespace);
    }
    
    XmlElement? writeElementWithType(Object? obj, Object? type, String name, String namespace, XmlElement parent,bool skipNullProperty)
    {
        if (obj == null && skipNullProperty)
        {
            return null;
        }
        var propertyElement=writeElement(name, namespace);
        parent.children.add(propertyElement);
            
        if (obj==null)
        {
            addAttribute(propertyElement,"nil",GQBHelper.XSI,"true");
            return null;
        }

        if  (obj is GQBIReferenceObject)
        {
            var idStr=_reverseReferencesTable[obj];
            if (idStr != null)
            {
                addAttribute(propertyElement,"Ref",GQBHelper.MS_SERIALIZATION_NS,idStr);
                return null;
            }

            int id=_reverseReferencesTable.length+1;
            idStr="i$id";
            addAttribute(propertyElement,"Id",GQBHelper.MS_SERIALIZATION_NS,idStr);
            _reverseReferencesTable[obj]=idStr;
        }

        var currentType=obj.runtimeType;
        if (currentType != type)
        {
            var xmlType=_reverseClassNames[currentType];
            if (xmlType != null)
            {
                var splitType = xmlType.split('^^');
                var fullname=_getXmlFullName(splitType[1], splitType[0]);
                addAttribute(propertyElement,"type",GQBHelper.XSI,fullname);
            }
        }

        return propertyElement;
    }

    String? _getNamespacePrefix(String? namespace)
    {
        if(namespace!=null)
        {
            return _ensureNamespace(namespace);
        }

        return null;
    }

    String _getXmlFullName(String name, String? uri)
    {
        var prefix=_getNamespacePrefix(uri);
        var fullname=name;
        if (prefix != null)
        {
            fullname=prefix+":"+name;
        }
        return fullname;
    }
    
    Encoding _encodingForCharset(String? charset, [Encoding fallback = latin1]) {
        if (charset == null)
        {
            return fallback;
        }
        return Encoding.getByName(charset) ?? fallback;
    }

    Future<String> _getResponseXml(GQBResponseData response) async
    {

        var contentTypeHeader=response.headers["content-type"];
        if(contentTypeHeader!=null)
        {
            var contentType=ContentType.parse(contentTypeHeader);
            var encoding=_encodingForCharset(contentType.parameters['charset']);
            return encoding.decode(response.bodyBytes);
        }
        throw Exception("No body content");
    }

    Future<XmlDocument> setResponse(GQBResponseData response) async
    {
        String responseBody = await _getResponseXml(response);
        var parsedXml = XmlDocument.parse(responseBody);

        if(parsedXml.rootElement==null)
        {
            throw Exception(responseBody);
        }
        OutputBody=GQBHelper.getNode(parsedXml.rootElement,"Body",soapNS);
        OutputHeader=GQBHelper.getNode(parsedXml.rootElement,"Header",soapNS);
        if(OutputBody==null)
        {
            throw Exception(responseBody);
        }

        var fault=GQBHelper.getNode(OutputBody!, "Fault",soapNS);
        if (fault != null)
        {
            var faultString=GQBHelper.getNodeByLocalName(fault, "faultstring");
            if (faultString == null)
            {
                var reasonNode=GQBHelper.getNodeByLocalName(fault, "Reason");
                if( reasonNode != null)
                {
                    faultString=GQBHelper.getNodeByLocalName(reasonNode, "Text");
                }
            }

            var faultDetail=GQBHelper.getNodeByLocalName( fault, "detail");
            if (faultDetail == null)
            {
                faultDetail=GQBHelper.getNodeByLocalName(fault, "Detail");
            }

            if (faultDetail != null)
            {
                var faultClass=faultDetail.childElements.firstOrNull;
                if (faultClass != null)
                {
                    var typeName=faultClass.name.local;
                    var namespaceNode=_resolveNamespace(faultClass,typeName);
                    String? namespace;
                    if(namespaceNode==null)
                    {
                        namespace=faultClass.name.namespaceUri;
                    }
                    else
                    {
                        namespace=namespaceNode;
                    }
                    var classType="$namespace^^$typeName";
                    var tempKey=_elementNames[classType];
                    if (tempKey != null)
                    {
                        classType=tempKey;
                    }
                    var temp=_classNames[classType];
                    if (temp != null)
                    {
                        var faultObj = await createInstance(faultClass, temp);
                        var faultException =  faultObj as Exception?;
                        if(faultException == null)
                        {
                            faultException = GQBSoapException.WithFault(faultObj);
                        }
                        throw faultObj;
                    }
                }
            }
            throw GQBSoapException(faultString?.innerText,faultDetail);

        }
        return parsedXml;
    }
    
    String? _resolveNamespace(XmlNode doc,String prefix){
        var iter=doc.document!.descendantElements.iterator;
        while(iter.moveNext())
        {
            var element=iter.current;
            var ns=element.attributes.where((attr) {
                var res= attr.name.local==prefix && attr.name.prefix=="xmlns";
                return res;
            }).firstOrNull;
            if(ns!=null)
            {
                return ns.value;
            }
        }
        return null;
    }

    Future<Object?> createObject(XmlElement node, CreatorFunction? creator ) async
    {
        var localCreator=creator;
        var localNode=node;
        var refAttr=node.getAttribute("Ref",namespace:GQBHelper.MS_SERIALIZATION_NS);
        if (refAttr != null)
        {
            return _referencesTable[refAttr];
        }

        var nilAttr=node.getAttribute("nil", namespace: GQBHelper.XSI);
        if (nilAttr != null && GQBHelper.toBoolFromString( nilAttr))
        {
            return null;
        }

        var typeAttr=node.getAttribute("type", namespace:GQBHelper.XSI);
        if (typeAttr != null)
        {
            var splitString=typeAttr.split(":");
            String? namespace;
            if(splitString.length==2)
            {
                namespace=_resolveNamespace(node,splitString[0]);
            }
            namespace ??= "";
            var typeName=splitString.length == 2 ? splitString[1] : typeAttr;
            var classType=namespace+"^^"+typeName;
            if(_classNames.containsKey(classType))
            {
                localCreator=_classNames[classType] as CreatorFunction;
            }
        }

        var hrefAttr = node.getAttribute("href");
        if (hrefAttr == null)
        {
            hrefAttr = node.getAttribute("ref");
        }

        if (hrefAttr != null)
        {
            var hrefId=hrefAttr.substring(1);
            var tempNode=node.document!.descendantElements.singleWhere((e) => e.getAttribute("id")==hrefId);

            if (tempNode!=null)
            {
                localNode=tempNode;
            }
        }
        if(localCreator!=null)
        {
            var obj=await createInstance(localNode, localCreator);
            return obj;
        }
        return null;
    }

    Future<Object> createInstance(XmlElement node,CreatorFunction creator ) async
    {
        var instance=creator();
        var idAttr = node.getAttribute("Id",namespace:GQBHelper.MS_SERIALIZATION_NS);
        if (idAttr != null)
        {
            _referencesTable[idAttr]=instance;
        }
        await instance.loadWithXml(node,this);
        return instance;
    }

    Future<Object> getAny(XmlElement node) async
    {
        if(createClassesForAny)
        {
            var typeName=node.name.local;
            var namespaceNode=_resolveNamespace(node,typeName);
            String? namespace;
            if(namespaceNode==null)
            {
                namespace=node.name.namespaceUri;
            }
            else
            {
                namespace=namespaceNode;
            }
            var classType="$namespace^^$typeName";
            var tempKey=_elementNames[classType];
            if (tempKey != null)
            {
                classType=tempKey;
            }
            var temp=_classNames[classType];
            if (temp != null)
            {
                var obj = await createInstance(node, temp);
                return obj;
            }
        }

        return node;
    }
    
    Future<ByteData?> getBinary(XmlNode? element, bool isSwaRef, bool isAttribute) async
    {
        if (element == null)
        {
            return null;
        }

        if(isAttribute)
        {
            return ByteData.sublistView(base64.decode((element as XmlAttribute).value));
        }
        else
        {
            return ByteData.sublistView(base64.decode(element.innerText));
        }
    }

    Future<void> setBinary(XmlNode? propertyElement, ByteData? data, bool isSwaRef, bool isAttribute) async
    {
        if(data==null || propertyElement==null)
        {
            return;
        }
    
        if(isAttribute)
        {
            (propertyElement as XmlAttribute).value= base64.encode(data.buffer.asUint8List());
        }
        else
        {
            propertyElement.innerText = base64.encode(data.buffer.asUint8List());
        }
    }
        

    void addWSAddressingHeaders(String action,String replyTo,String to, List<String> referenceParameters)
    {
        var wsaddressingElement=writeElement("Action", "http://www.w3.org/2005/08/addressing");
        Header!.children.add(wsaddressingElement);
        wsaddressingElement.innerText = action;
        addAttribute(wsaddressingElement,"mustUnderstand", soapNS, "1");
        wsaddressingElement=writeElement( "MessageID", "http://www.w3.org/2005/08/addressing");
        Header!.children.add(wsaddressingElement);
        wsaddressingElement.innerText = "urn:uuid:" + const Uuid().v4();
        wsaddressingElement=writeElement( "ReplyTo", "http://www.w3.org/2005/08/addressing");

        Header!.children.add(wsaddressingElement);
        var innerWsaddressingElement=writeElement("Address", "http://www.w3.org/2005/08/addressing");
        innerWsaddressingElement.innerText = replyTo;
        wsaddressingElement.children.add(innerWsaddressingElement);

        wsaddressingElement=writeElement( "To", "http://www.w3.org/2005/08/addressing");
        Header!.children.add(wsaddressingElement);
        wsaddressingElement.innerText = to;
        addAttribute( wsaddressingElement,"mustUnderstand", soapNS, "1");

        for (var param in referenceParameters) {
            var root=XmlDocument.parse(param);
            var element=root.rootElement.copy();
            Header!.children.add(element);
            addAttribute(element, "IsReferenceParameter", "http://www.w3.org/2005/08/addressing", "true");
        }
    }
    
    Future<void> setAnyTypeValue(Object item, XmlElement propertyElement) async
    {
        if (item is GQBISerializableObject)
        {
            await item.serialize(propertyElement ,this);
        }
        else if(item is String)
        {
            var prefix=_getNamespacePrefix( "http://www.w3.org/2001/XMLSchema");
            addAttribute(propertyElement,"type", "http://www.w3.org/2001/XMLSchema-instance", "$prefix:string");
            propertyElement.innerText = item;
        }
        else if(item is bool)
        {
            var prefix=_getNamespacePrefix( "http://www.w3.org/2001/XMLSchema");
            addAttribute(propertyElement,"type", "http://www.w3.org/2001/XMLSchema-instance", "$prefix:boolean");
            propertyElement.innerText = item.toString();
        }
        else if (item is num)
        {
            var prefix=_getNamespacePrefix( "http://www.w3.org/2001/XMLSchema");
            if (item is int)
            {
              addAttribute(propertyElement,"type", "http://www.w3.org/2001/XMLSchema-instance", "$prefix:int");
            }
            else if (item is double)
            {
                addAttribute(propertyElement,"type", "http://www.w3.org/2001/XMLSchema-instance", "$prefix:double");
            }
            propertyElement.innerText = item.toString();
        }
        else
        {
          propertyElement.innerText = item.toString();
        }
    }

    Future<Object> getAnyTypeValue(XmlElement node) async
    {
        var typeAttr=node.getAttribute("type",namespace: GQBHelper.XSI);
        if (typeAttr != null)
        {
            var splitString=typeAttr.split(":");
            if (splitString.length==2)
            {              
                var namespace=_resolveNamespace(node, splitString[0]);
                if (namespace == "http://www.w3.org/2001/XMLSchema")
                {
                    var value=splitString[1];
                    if( value == "int" || value == "double" || value == "float" || value == "long" || value == "integer" || value == "byte" || value == "negativeInteger"
                        || value == "nonNegativeInteger" || value == "nonPositiveInteger" || value == "positiveInteger" || value == "short" || value == "unsignedLong" || value == "unsignedInt"
                        || value == "unsignedShort" || value == "unsignedByte" || value == "decimal")
                    {
                      return num.parse(node.innerText);
                    }
                    else if (value == "bool")
                    {
                      return node.innerText=="true";
                    }
                    else
                    {
                      return  node.innerText;
                    }
                }
                else
                {
                    var typeName=splitString.length==2 ? splitString[1] : typeAttr;
                    if (namespace != null)
                    {
                        var classType="$namespace^^$typeName";
                        var temp=_classNames[classType];
                        if (temp != null)
                        {
                            var obj = await createInstance(node, temp);
                            return obj;
                        }
                    }
                }
            }
        }
        return node;
    }
    
}
   
